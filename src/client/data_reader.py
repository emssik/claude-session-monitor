#!/usr/bin/env python3

import json
import os
import time
import logging
from typing import Optional
from datetime import datetime

try:
    from ..shared.data_models import MonitoringData
except ImportError:
    from shared.data_models import MonitoringData


class DataReader:
    """
    Reads monitoring data from JSON files generated by the daemon.
    
    Provides caching, daemon status detection, and graceful error handling
    for file-based data access in the client-server architecture.
    """

    def __init__(self, file_path: str, cache_duration: float = 1.0, daemon_timeout: float = 60.0):
        """
        Initialize DataReader with file path and caching configuration.
        
        Args:
            file_path: Path to the monitoring data JSON file
            cache_duration: How long to cache data in memory (seconds)
            daemon_timeout: How old file can be to consider daemon running (seconds)
        """
        self.file_path = file_path
        self.cache_duration = cache_duration
        self.daemon_timeout = daemon_timeout
        
        # Cache variables
        self._cached_data: Optional[MonitoringData] = None
        self._cache_timestamp: float = 0.0
        
        # Setup logging
        self.logger = logging.getLogger(__name__)

    def read_data(self, force_refresh: bool = False) -> Optional[MonitoringData]:
        """
        Read monitoring data from file with caching.
        
        Args:
            force_refresh: If True, bypass cache and read from file
            
        Returns:
            MonitoringData object if successful, None if file doesn't exist or is invalid
        """
        current_time = time.time()
        
        # Check cache validity
        if (not force_refresh and 
            self._cached_data is not None and 
            current_time - self._cache_timestamp < self.cache_duration):
            return self._cached_data
        
        # Check if daemon is running before reading data
        if not self.is_daemon_running():
            self.logger.debug(f"Daemon not running - file too old or missing: {self.file_path}")
            return None
        
        # Try to read from file
        try:
            if not os.path.exists(self.file_path):
                self.logger.debug(f"Data file not found: {self.file_path}")
                return None
                
            with open(self.file_path, 'r') as f:
                data_dict = json.load(f)
            
            # Convert to MonitoringData object
            monitoring_data = MonitoringData.from_dict(data_dict)
            
            # Update cache
            self._cached_data = monitoring_data
            self._cache_timestamp = current_time
            
            self.logger.debug(f"Successfully read monitoring data from {self.file_path}")
            return monitoring_data
            
        except FileNotFoundError:
            self.logger.debug(f"Data file not found: {self.file_path}")
            return None
        except json.JSONDecodeError as e:
            self.logger.warning(f"Invalid JSON in data file {self.file_path}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Error reading data file {self.file_path}: {e}")
            return None

    def is_daemon_running(self) -> bool:
        """
        Check if daemon is likely running based on file freshness.
        
        Returns:
            True if daemon appears to be running (file is fresh), False otherwise
        """
        file_age = self.get_file_age()
        return file_age < self.daemon_timeout

    def get_file_age(self) -> float:
        """
        Get age of the data file in seconds.
        
        Returns:
            Age in seconds, or very large number if file doesn't exist
        """
        try:
            if not os.path.exists(self.file_path):
                return 999999.0  # Very old if doesn't exist
                
            stat = os.stat(self.file_path)
            return time.time() - stat.st_mtime
        except OSError:
            return 999999.0

    def clear_cache(self):
        """Clear cached data to force fresh read on next access."""
        self._cached_data = None
        self._cache_timestamp = 0.0
        self.logger.debug("DataReader cache cleared")

    def get_cache_age(self) -> float:
        """
        Get age of cached data in seconds.
        
        Returns:
            Age of cache in seconds, or very large number if no cache
        """
        if self._cached_data is None:
            return 999999.0
        return time.time() - self._cache_timestamp

    def __str__(self) -> str:
        """String representation showing file path and cache status."""
        cache_status = "cached" if self._cached_data is not None else "no cache"
        daemon_status = "running" if self.is_daemon_running() else "not running"
        return f"DataReader({self.file_path}, {cache_status}, daemon {daemon_status})"